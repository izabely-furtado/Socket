{
  "name": "Socket",
  "tagline": "Um chat utilizando sockets.",
  "body": "# Relatório\r\n\r\nO objetivo deste laboratório é fazer um chat utilizando sockets.\r\n\r\nUtilizando os exemplos do link abaixo:\r\n\r\nhttp://www.cs.rpi.edu/~moorthy/Courses/os98/Pgms/socket.html\r\n\r\nEstes foram alterados para implementar um chat.\r\n\r\nQuando um dos usuários digitar \"bye\" a conexão deve ser encerrada.\r\n\r\nHouveram duas implementações\r\nEm java = na pasta javaSocket (mais válida)\r\nEm c = na pasta cSocket\r\n\r\n## Motivações\r\n\r\nO processo de utilização sockets em um programa para que haja comunicação contém processos bloqueantes, caso este programa esteja em apenas um fluxo de execução. Essas chamadas bloqueantes são chamadas de leitura.\r\n\r\nAs chamadas de leitura esperam uma resposta \r\n* onde o servidor, por exemplo se paralisa naquele trecho de código até que alguma resposta seja emitida do lado do cliente, caso esse cliente nunca mande uma mensagem, isso pode causar um deadlock.\r\n* Agora suponhamos que o cliente mandou uma mensagem, a partir desse momento, este precisa esperar de uma resposta do servidor indicando que a mensagem foi enviada com sucesso, antes disso, não pode haver o envio de outra mensagem\r\n\r\n### Threads e vários clientes\r\n\r\nCriando vários fluxos de execução e deixando pelo ou menos uma thread responsável somente pela leitura, essa chamada deixa de bloquear o programa como um todo. Assim, caso o cliente queira enviar N mensagens, essas vão ser processadas por outras threads.\r\n\r\nAlém de evitar o deadlock a criação de threads pode colaborar para a criação de uma sala virtual com 10 clientes, por exemplo, onde nenhum destes estaria bloqueado de enviar ou receber mensagens, dado que tanto servidor, quanto no cliente o programa segue executando em paralelo as funções de **Read** e **Write**.\r\n\r\n## Modificações\r\n\r\n### Use uma thread adicional\r\n\r\nPara que se elabore um programa em que o número de mensagens enviada por um dos usuários seja independente do número de mensagens enviada pelo outro o processo é o seguinte: usa-se uma thread a mais para processar a leitura. Dado assim a cada thread um objetivo.\r\n\r\n**Em C**\r\n\r\n\r\n`\r\n\r\n//criando threads\r\n\r\n\r\nvoid CriaThread(int sockfd) {\r\n\r\n\r\n\tint i, k;\r\n\t//int nProc = get_nprocs();\r\n\tint nProc = 2;\r\n\r\n\t//criando vetor de threads\r\n\tthreads[nProc] = (pthread_t *) malloc(nProc * sizeof (pthread_t));\r\n\r\n\t//dando a cada thread um objetivo\r\n\t\r\n\tpthread_create(&(threads[0]), NULL, &Read, sockfd);\r\n\tpthread_create(&(threads[i]), NULL, &Write, sockfd);\r\n\t\r\n\t//mandando bala\r\n\tfor (k = 0; k < nProc; k++) {\r\n\t\tpthread_join(threads[k], NULL);\r\n\t}\r\n\r\n\r\n}\r\n\r\n`\r\n\r\n**Em Java**\r\n\r\nA partir da versao4 indicada no github, para que o servidor seja capaz de trabalhar com dois clientes ao mesmo tempo é necessário criar uma thread logo após executar o método accept.\r\n\r\nA thread criada será responsável pelo tratamento dessa conexão, enquanto o laço do servidor disponibilizará a porta para uma nova conexão:\r\n\r\n`\r\n\r\nwhile (true) {\r\n\r\n  Socket cliente = servidor.accept();\r\n\r\n  // cria um objeto que vai tratar a conexão\r\n  Controlador serv = new Controlador(cliente);\r\n\r\n  // cria a thread em cima deste objeto\r\n  Thread t = new Thread(tratamento);\r\n\r\n  // inicia a thread\r\n  t.start();\r\n\r\n}\r\n\r\n`\r\n\r\n\r\n### 10 Clientes\r\n\r\n**Em C**\r\n\r\n**No servidor**\r\n\r\n`\r\n\r\n//criando threads\r\n\r\n\r\nvoid CriaThread(int newsockfd) {\r\n\r\n\r\n\tint i, k;\r\n\t//int nProc = get_nprocs();\r\n\tint nProc = 11;\t\t//10 clientes para ler msg e um para enviar resposta\r\n\r\n\t//criando vetor de threads\r\n\tthreads[nProc] = (pthread_t *) malloc(nProc * sizeof (pthread_t));\r\n\r\n\t//dando a cada thread um objetivo\r\n\tpthread_create(&(threads[0]), NULL, &Write, newsockfd)\r\n\t\r\n\tfor (i = 1; i < nProc; i++) {\r\n\t\tpthread_create(&(threads[i]), NULL, &Read, newsockfd);\r\n\t}\r\n\t\r\n\t//mandando bala\r\n\tfor (k = 0; k < nProc; k++) {\r\n\t\tpthread_join(threads[k], NULL);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n`\r\n\r\n\r\n\r\n\r\n**No Cliente**\r\n\r\n`\r\n\r\n//criando threads\r\n\r\n\r\nvoid CriaThread(int sockfd) {\r\n\r\n\r\n\tint i, k;\r\n\t//int nProc = get_nprocs();\r\n\tint nProc = 11;\t\t//10 clientes e um para ler msgs do servidor\r\n\r\n\t//criando vetor de threads\r\n\tthreads[nProc] = (pthread_t *) malloc(nProc * sizeof (pthread_t));\r\n\r\n\t//dando a cada thread um objetivo\r\n\t\r\n\tpthread_create(&(threads[0]), NULL, &Read, sockfd);\r\n\t\r\n\tfor (i = 1; i < nProc; i++) {\r\n\t\tpthread_create(&(threads[i]), NULL, &Write, sockfd);\r\n\t}\r\n\t\r\n\t//mandando bala\r\n\tfor (k = 0; k < nProc; k++) {\r\n\t\tpthread_join(threads[k], NULL);\r\n\t}\r\n\r\n\r\n}\r\n\r\n`\r\n\r\n**Em Java**\r\n\r\nFoi Elaborado um controlador e um Servente, para que as threads pudessem ser utilizadas executando o run() dessas classes\r\n\r\nNo controlador indica a parada de conexão com os clientes\r\n\r\n`\r\n\r\npublic void run() {\r\n        // quando chegar uma msg, distribui pra todos\r\n        Scanner entrada = new Scanner(this.cliente);\r\n        //lendo entradas dos clientes até bye\r\n        while (entrada.hasNextLine()) {\r\n            servidor.escreve(entrada.nextLine());\r\n            String entra = entrada.nextLine();\r\n            if (\"bye\".equals(entra)) {\r\n                try {\r\n                    //fecha cliente\r\n                    this.cliente.close();\r\n                } catch (IOException ex) {\r\n                    break;\r\n                }\r\n                System.out.println(\"Cliente saiu\");\r\n                break;\r\n            }\r\n        }\r\n        entrada.close();\r\n        \r\n    }\r\n\r\n\r\n`\r\n\r\n\r\n\r\n## Servidor\r\n\r\n### Read\r\n\r\n\r\n**Em C**\r\n\r\n\r\n`\r\n\r\n//lendo do buffer\r\n\r\n\r\nvoid *Read(int newsockfd) {\r\n\r\n\r\n\t\r\n    bzero(buffer,256);\r\n    n = read(newsockfd,buffer,255);\r\n    if (n < 0) {\r\n\t\terror(\"ERROR reading from socket\");\r\n    }\r\n    while (strcmp(buffer, \"bye\")!=0){\r\n    \tprintf(\"Here is the message: %s\\n\",buffer);\r\n    }\r\n    printf(\"Comunicação encerrada\");\r\n\r\n\r\n\r\n}\r\n\r\n\r\n`\r\n\r\n**Em Java**\r\n\r\n\r\nA leitura é mostrada no controlador\r\n\r\n\r\n\r\n### Write\r\n\r\n**Em C**\r\n\r\n`\r\n\r\n\r\n//escrevendo no buffer\r\n\r\n\r\nvoid *Write(int newsockfd){\r\n\r\n\r\n\tint n;\r\n\t\r\n\tn = write(newsockfd,\"I got your message\",18);\r\n        if (n < 0) {\r\n\t\t error(\"ERROR writing to socket\");\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n`\r\n\r\n**Em Java**\r\n\r\n`\r\n\r\npublic void escreve(String msg) {\r\n        // envia msg para todo mundo\r\n        for (PrintStream cliente : this.clientes) {\r\n            cliente.println(msg + \" foi recebido\");\r\n        }\r\n    }\r\n\r\n\r\n`\r\n\r\n## Cliente\r\n\r\n\r\n### Write\r\n\r\n**Em C**\r\n\r\n\r\n`\r\n\r\n//escrevendo no buffer\r\n\r\n\r\nint *Write(int sockfd){\r\n\r\n\r\n\tint n;\r\n\t\r\n\tdo{\r\n\t\tbzero(buffer,256);\r\n\t\tfgets(buffer,255,stdin);\r\n\t\tprintf(\"Please enter the message: \");\r\n\t\t\r\n\t\tn = write(sockfd,buffer,strlen(buffer));\r\n\t\r\n\t\tif (n < 0) {\r\n\t\t\terror(\"ERROR writing to socket\");\r\n\t\t}\r\n\r\n\t}while (strcmp(buffer, \"bye\")!=0)\r\n\t\r\n\treturn sockfd;\r\n\r\n\r\n}\r\n\r\n`\r\n\r\n\r\n### Read\r\n\r\n\r\n`\r\n\r\n//lendo do buffer\r\n\r\n\r\nvoid *Read(int sockfd) {\r\n\r\n\r\n\tint n;\r\n        n = read(sockfd,buffer,255);\r\n        if (n < 0) \r\n             error(\"ERROR reading from socket\");\r\n         printf(\"%s\\n\",buffer);\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n`\r\n\r\n**Em Java**\r\n\r\n##Lendo e Escrevendo\r\n\r\n`\r\n\r\n//lendo do teclado e enviado para o servidor\r\n    public void leituraEscrita() throws IOException {\r\n        Scanner teclado = new Scanner(System.in);\r\n        PrintStream saida = new PrintStream(this.cliente.getOutputStream());\r\n\r\n        while (teclado.hasNextLine()) {\r\n            String sai = teclado.nextLine();\r\n            saida.println(sai);\r\n            if (\"bye\".equals(sai)) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        //impossibilitando novas envios ao servidor\r\n        saida.close();\r\n        //impossibilitando novas leituras do teclado\r\n        teclado.close();\r\n\r\n    }\r\n\r\n`\r\n\r\nEXECUTE PRIMEIRO O SERVIDOR E DEPOIS O CLIENTE (EM C) OU CONTROLADOR (EM JAVA)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}